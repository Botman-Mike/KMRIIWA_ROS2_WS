Please update our Java TCP client so that every outgoing message is framed exactly like the Python side:

Append \r\n to the payload string.
Compute its UTF-8 byte length, format it as a zero-padded 10-digit ASCII string.
Send [length][space][payload+CRLF] over the socket.

Also, implement your receiver using the CRLF-flush sync approach:

 1. Read exactly 11 bytes (10-digit length + space).
 2. If the header is invalid, read and discard bytes until you see the sequence "\r\n", then restart step 1.

Be aware: if your payload may include embedded CRLF, this flush method could misinterpret an internal CRLF as a frame delimiter. In that case, use a sliding-window scan instead.

For example:
```java
// CRLF-flush header sync
int length;
while (true) {
    byte[] headerRaw = new byte[11];
    inputStream.readFully(headerRaw);
    // check for 10 ASCII digits then space
    boolean valid = true;
    for (int i = 0; i < 10; i++) {
        if (headerRaw[i] < '0' || headerRaw[i] > '9') { valid = false; break; }
    }
    if (valid && headerRaw[10] == ' ') {
        length = Integer.parseInt(new String(headerRaw, 0, 10, StandardCharsets.UTF_8));
        break;
    }
    // invalid header: flush until CRLF
    int prev = -1;
    int curr;
    do {
        curr = inputStream.read();
    } while (prev != '\r' || curr != '\n');
    prev = curr;
}
// now read exactly length bytes of payload+CRLF
byte[] payload = new byte[length];
inputStream.readFully(payload);
// payload should end with CRLF
```
